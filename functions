# double line
double_line() {
    echo;echo
}

# info logs the given argument at info log level.
info() {
    echo "[INFO] " "$@"
}

# warn logs the given argument at warn log level.
warn() {
    echo "[WARN] " "$@" >&2
}

# fatal logs the given argument at fatal log level.
error() {
    echo "[ERR] " "$@" >&2
}

# show usage of this tool
usage() {
    echo "${KF_USAGE}"
}

# check KF_VERSION is correct
check_kf_version() {
    if [ -z ${KF_VERSION} ]; then
        error "::: Please set the version of Kubeflow in '${KF_VERSION}' Variable..."
        exit 1
    fi
    
}

# 0. clone git and working directory
clone_git() {
    KF_VERSION=${1}
    check_kf_version
    WORK_DIR=manifests
    git clone ${KF_GIT_URL} ${WORK_DIR}
    cd ${WORK_DIR}
    if [ ! -d ${WORK_DIR} ]; then
        error "::: ${WORK_DIR} is not exist ..."
        exit 1
    else
        git checkout ${KF_VERSION}
    fi
}

# 1. install cert-manager
install_cert_manager() {
    info "::: Install Cert-Manager ..."
    if [ "${DRYRUN}" != 1 ]; then
        kustomize build common/cert-manager/base | kubectl apply -f -
        kubectl wait --for=condition=Ready pod -l 'app in (cert-manager,webhook)' \
         --timeout ${TIMEOUT1} -n cert-manager
        info "Waiting for cert-manager to be ready ..."
        kustomize build common/cert-manager/kubeflow-issuer/base | kubectl apply -f -
        kubectl wait --for=jsonpath='{.subsets[0].addresses[0].targetRef.kind}'=Pod endpoints \
         -l 'app in (cert-manager,webhook)' --timeout ${TIMEOUT1} -n cert-manager
    fi
    info "::: Finish installation Cert-Manager ..."
}

# 2. install istio
install_istio() {
    info "::: Install Istio ..."
    if [ "${DRYRUN}" != 1 ]; then
        info "Installing Istio configured with external authorization..."
        kustomize build common/istio-1-24/istio-crds/base | kubectl apply -f -
        kustomize build common/istio-1-24/istio-namespace/base | kubectl apply -f -
        kustomize build common/istio-1-24/istio-install/overlays/oauth2-proxy | kubectl apply -f -

        info "Waiting for all Istio Pods to become ready..."
        kubectl wait --for=condition=Ready pods --all -n istio-system --timeout ${TIMEOUT2}
    fi
    info "::: Finish installation Istio ..."
}

# 3. install oauth2-proxy
install_oauth2_proxy() {
    info "::: Install Oauth2-Proxy ..."
    if [ "${DRYRUN}" != 1 ]; then
        kustomize build common/oauth2-proxy/overlays/m2m-dex-only/ | kubectl apply -f -
        kubectl wait --for=condition=Ready pod -l 'app.kubernetes.io/name=oauth2-proxy' --timeout ${TIMEOUT1} -n oauth2-proxy
    fi
    info "::: Finish installation Oauth2-Proxy ..."
}

# install dex
install_dex() {
    info "::: Install Dex ..."
    if [ "${DRYRUN}" != 1 ]; then
        kustomize build common/dex/overlays/oauth2-proxy | kubectl apply -f -
        kubectl wait --for=condition=Ready pods --all --timeout ${TIMEOUT1} -n auth
    fi
    info "::: Finish installation Dex ..."
}

# install knative - WIP
install_knative() {
    info "::: Install Knative ..."
    if [ "${DRYRUN}" != 1 ]; then
        kustomize build common/knative/knative-serving/overlays/gateways | kubectl apply -f -
        kustomize build common/istio-1-24/cluster-local-gateway/base | kubectl apply -f -
        # check whether knative is installed or not
        # need to check the below command
        kubectl wait --for=condition=Ready pods --all --timeout ${TIMEOUT1} -n knative-serving
    fi
    info "::: Finish installation Knative ..."
}

# Kubeflow Namespace, NetworkPolicy, Roles and Istio Resources - WIP
install_kubeflow_resources() {
    info "::: Install Kubeflow namespace, network policy, roles and Istio resources..."
    if [ "${DRYRUN}" != 1 ]; then
        kustomize build common/kubeflow-namespace/base | kubectl apply -f -
        kustomize build common/networkpolicies/base | kubectl apply -f -
        kustomize build common/kubeflow-roles/base | kubectl apply -f -
        kustomize build common/istio-1-24/kubeflow-istio-resources/base | kubectl apply -f -
        # need to check the below command
        kubectl wait --for=condition=Ready pods --all --timeout ${TIMEOUT1} -n kubeflow
    fi
    info "::: Finish installation Kubeflow ..."
}


# tools
# install gum
install_gum() {
    if ! $(which gum &> /dev/null); then
        info "::: Install GUM ..."
        if [ "${DRYRUN}" != 1 ]; then
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://repo.charm.sh/apt/gpg.key | gpg --dearmor -o /etc/apt/keyrings/charm.gpg
            echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | tee /etc/apt/sources.list.d/charm.list
            apt update && apt install gum=${OS_GUM_VER}
        fi
        info "::: Finish installation GUM ..."
    else
        info "::: GUM is already installed ..."
    fi
}

# install helm
install_helm() {
    info "::: Install Helm ..."
    if [ "${DRYRUN}" != 1 ]; then
        curl ${HELM_INSTALL} | DESIRED_VERSION=${OS_HELM_VER} bash
        helm completion bash > /etc/bash_completion.d/helm
    fi
    info "::: Finish installation Helm ..."
}

# install yjq
install_yjq() {
    if ! $(which yq &> /dev/null); then
        info "::: Install yq ..."
        wget ${YQ_URL} -O /usr/bin/yq && chmod +x /usr/bin/yq
    fi

    if ! $(which jq &> /dev/null); then
        info "::: Install jq ..."
        apt install -y jq=${OS_JQ_VER}
    fi
}

# Show title
show_title() {
    if [ "${DRYRUN}" = 1 ]; then
        TITLE_MESSAGE="Running Dry-run mode ..."
    else
        TITLE_MESSAGE="Initialize Installation of ${1} ..."
    fi
    gum style \
        --foreground 212 --border-foreground 212 --border double \
        --align center --width 50 --margin "1 2" --padding "2 4" \
        'Kubeflow INIT' "${TITLE_MESSAGE}"
}

# Check all commands requiring
check_requiring_tools() {
    if (which kubectl) && (which helm) && (which argocd) && (which mkcert) && (which k9s); then
        info "::: kubectl, helm, argocd and mkcert - All requiring tools are exist."
        info "::: It's Ready to Initiate ${PRIME_NAME}"
    else
        error "::: All requiring tools are Not Exist..."
        error "::: Please Check these tools out - kubectl, helm, argocd and mkcert ..."
    fi
}


# copy Cert to another namespace
copy_cert() {
    if [ ! -z ${1} ]; then
        TARGET_NS=$1
        k get secret -l cert=${RKE2_CERT_NAME} -n kube-system -ojson | jq 'del(.items[0].metadata["namespace","creationTimestamp","resourceVersion","selfLink","uid"])' | kubectl apply -n ${TARGET_NS} -f -
    else
        echo -e "Usage: copy_cert [namespace]\n"
    fi
}


# Function to determine OS type and CPU architecture
get_os_and_arch() {
    # Step 1: Detect the Operating System type
    info "::: Detecting operating system type..."
    OS_TYPE=$(uname -s)

    case "$OS_TYPE" in
        Darwin)
            OS_TYPE="darwin"
            ;;
        Linux)
            OS_TYPE="linux"
            ;;
        *)
            warn "::: Unsupported Operating System: $OS_TYPE"
            return 1
            ;;
    esac
    info "::: Operating System detected: $OS_TYPE"

    # Step 2: Detect the CPU architecture
    info "::: Detecting CPU architecture..."
    ARCH_TYPE=$(uname -m)

    case "$ARCH_TYPE" in
        x86_64)
            ARCH_TYPE="amd64"
            ;;
        arm64|aarch64)
            ARCH_TYPE="arm64"
            ;;
        *)
            warn "::: Unsupported CPU architecture: $ARCH_TYPE"
            return 1
            ;;
    esac
    info "::: CPU Architecture detected: $ARCH_TYPE"

    # Return values
    OS_AND_ARCH="${OS_TYPE}-${ARCH_TYPE}"
}


# Install argocd-CLI
install_tools_cli() {
    get_os_and_arch
    # install argocd-cli
    ARGOCD_CLI=${RKE2_ARGOCLI_URL}/argocd-${OS_AND_ARCH}
    curl -sSL -O ${ARGOCD_CLI} # leave filename
    sudo mv ${ARGOCD_CLI##*/} /usr/local/bin/argocd && chmod +x /usr/local/bin/argocd

    # install mkcert
    MKCERT_CLI=${RKE2_MKCERT_URL}/mkcert-${RKE2_MKCERT_VER}-${OS_AND_ARCH}
    curl -sSL -O ${MKCERT_CLI} # leave filename
    sudo mv ${MKCERT_CLI##*/} /usr/local/bin/mkcert && chmod +x /usr/local/bin/mkcert

    # install k9s
    K9S_CLI=${RKE2_K9S_URL}/k9s_${OS_TYPE}_${ARCH_TYPE}.deb
    info "::: Download ${K9S_CLI} ..."
    curl -sSL -O ${K9S_CLI} && dpkg -i ./k9s_${OS_TYPE}_${ARCH_TYPE}.deb && rm -f ./k9s_${OS_TYPE}_${ARCH_TYPE}.deb

    check_requiring_tools
}


# get service domain
get_domain() {
    if $(gum confirm "Do you want to Set up the Self-Signed service domain? OR Else ${PRIME_DOMAIN} is used as a Default. "); then
        IS_LOOPING=0
        while [ ${IS_LOOPING} -eq 0 ]; do
            SVC_DOMAIN=$(gum input --header="::: Enter Service-Domain - " --value="aaaaa.com" --char-limit=100)
            if $(gum confirm "It will be used as Ingress Domain,, Confirm... "); then
                info "::: all Ingress domains are creating under ${SVC_DOMAIN}..."
                IS_LOOPING=1
            else
                gum confirm "Want to quit? Then It should be used by the Default domain ${PRIME_DOMAIN}" && IS_LOOPING=1
                SVC_DOMAIN=${PRIME_DOMAIN}
                info "::: all Ingress domains are creating under ${SVC_DOMAIN}..."
            fi
        done
    else
        SVC_DOMAIN=${PRIME_DOMAIN}
        info "::: all Ingress domains are creating under ${SVC_DOMAIN}..."
    fi
}

